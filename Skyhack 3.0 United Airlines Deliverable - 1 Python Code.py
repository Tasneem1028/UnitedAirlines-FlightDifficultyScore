# -*- coding: utf-8 -*-
"""SkyHack3.0: United Airlines Deliverable 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WFxjBmBxEeF9MfCwTYrPu26bQxOIXjqD

This notebook performs comprehensive exploratory data analysis on United Airlines
flight operations data from Chicago O'Hare International Airport (ORD).

The analysis addresses the specific EDA questions outlined in the competition:
1. Average delay and percentage of flights departing later than scheduled
2. Flights with scheduled ground time close to or below minimum turn minutes
3. Average ratio of transfer bags vs. checked bags across flights
4. Passenger load comparison and correlation with operational difficulty
5. Special service requests impact on delays controlling for load

# **Team: DuoLytics**

Competition: SkyHack 3.0 - United Airlines

Date: 3rd - 5th October 2025
"""

from google.colab import drive

drive.mount('/content/drive')

"""##Library Setup
Setting up essential libraries for data manipulation, statistical analysis, and visualization. These tools enable comprehensive analysis of airline operational data.



"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt

"""Load All datasets from the Google Drive

Dowloaded and saved the given CSV files in My Drive in a folder names SkyHack3.0: United Airlines.

## Data Loading and Initial Exploration

### Loading Strategy
We load all five datasets provided by United Airlines, covering different aspects of flight operations:
- Flight-level operational data (core dataset)
- Passenger booking records (PNR data)
- Special service requests (operational complexity indicators)  
- Baggage handling information (ground operations complexity)
- Airport reference data (route context)
"""

import glob

base_path = "/content/drive/My Drive/SkyHack 3.0: United Airlines/"

files = glob.glob(base_path + "*.csv")

# Display the files found
for f in files:
    print(f)

base_path = "/content/drive/MyDrive/SkyHack 3.0: United Airlines/"

flight_df = pd.read_csv(base_path + "Flight Level Data.csv")
pnr_flight_df = pd.read_csv(base_path + "PNR+Flight+Level+Data.csv")
pnr_remark_df = pd.read_csv(base_path + "PNR Remark Level Data.csv")
bag_df = pd.read_csv(base_path + "Bag+Level+Data.csv")
airport_df = pd.read_csv(base_path + "Airports Data.csv")

"""##Data Structure Analysis

### Understanding Our Datasets
Before analyzing operational patterns, we need to understand the structure and relationships between our datasets. This exploration helps us:
- Identify key columns for analysis
- Understand data types and formats
- Plan appropriate join strategies for comprehensive analysis
- Spot potential data quality issues early

"""

flight_df.head()

flight_df.columns

type(flight_df.actual_departure_datetime_local[0])

pnr_flight_df.head()

pnr_flight_df.columns

pnr_remark_df.head()

pnr_remark_df.columns

bag_df.head()

bag_df.columns

airport_df.head()

airport_df.columns

"""## Dataset Size Overview

### Data Volume Assessment
Understanding the scale of our datasets is crucial for:
- Planning computational approaches
- Identifying the most comprehensive data sources
- Understanding the operational scope (number of flights, passengers, etc.)
- Validating that we have sufficient data for statistical significance

"""

for name, df in {'Flight':flight_df, 'PNR Flight':pnr_flight_df,
                 'PNR Remark':pnr_remark_df, 'Bag':bag_df, 'Airport':airport_df}.items():
    print(f"\n{name} shape: {df.shape}")

"""# Question 1: Flight Delay Analysis

## Business Context
**Competition Question**: *"What is the average delay and what percentage of flights depart later than scheduled?"*

Departure delays are the most visible indicator of operational difficulty. They impact:
- **Passenger Experience**: Late departures affect connections and satisfaction
- **Operational Costs**: Delays cascade through the system, requiring recovery actions
- **Resource Allocation**: Understanding delay patterns helps optimize staffing and equipment
- **Competitive Position**: On-time performance is a key airline differentiator

### Key Metrics We're Computing:
- `departure_delay_min`: Actual - Scheduled departure time (minutes)
- Positive values = late departures, Negative values = early departures

"""

# What is the average delay and what percentage of flights depart later than scheduled?
# Creating the Departure Delay (mins) column in the Flight Level Data (flight_df)
flight_df['departure_delay_min'] = (
    pd.to_datetime(flight_df['actual_departure_datetime_local']) -
    pd.to_datetime(flight_df['scheduled_departure_datetime_local'])
).dt.total_seconds() / 60

flight_df['departure_delay_min'].value_counts()

"""So, we have early departures as well."""

flight_df.columns

type(flight_df['departure_delay_min'][0])

"""The average delay in departures considering only late departures."""

#Average of departure delay minutes without considering early departures
avg_delay_no_early = flight_df[flight_df['departure_delay_min'] > 0]['departure_delay_min'].mean()

avg_delay_no_early

avg_delay = flight_df['departure_delay_min'].mean()
late_pct = (flight_df['departure_delay_min'] > 0).mean() * 100 # If negative delay means departed earlier

"""The average here is considering the early departures too.

"""

print(f"Average delay: {avg_delay:.2f} mins | % Flights late: {late_pct:.2f}%")

flight_df.columns

has_duplicates = flight_df.duplicated().any()
print("Are there duplicate rows?", has_duplicates)

flight_df.shape

"""# Question 2: Ground Time Pressure Analysis

## Business Context
**Competition Question**: *"How many flights have scheduled ground time close to or below the minimum turn mins?"*

Ground time pressure is a critical operational risk factor. Flights with minimal turnaround buffers face:
- **Higher Delay Risk**: Less flexibility to absorb operational hiccups
- **Resource Strain**: Ground crews must work at maximum efficiency
- **Cascade Effects**: Tight turns can propagate delays throughout the day
- **Safety Considerations**: Rushing operations can compromise safety protocols

### Key Metrics:
- `is_below_min_turn`: Binary flag for flights at/below minimum turn time
- Risk assessment based on buffer size relative to minimum requirements

"""

# How many flights have scheduled ground time close to or below the minimum turn mins?
flight_df['is_below_min_turn'] = flight_df['scheduled_ground_time_minutes'] <= flight_df['minimum_turn_minutes']
below_turn_pct = flight_df['is_below_min_turn'].mean() * 100
print(f"{below_turn_pct:.2f}% flights have scheduled ground time <= minimum turn time")

"""#Question 3: Baggage Operations Analysis

## Business Context
**Competition Question**: *"What is the average ratio of transfer bags vs. checked bags across flights?"*

Baggage composition significantly affects operational complexity:
- **Transfer Bags**: Require coordination between flights, time-sensitive handling
- **Hot Transfer Bags**: Connection time <30 minutes, highest priority handling
- **Checked Bags**: Standard handling, more predictable operations
- **Resource Allocation**: Different bag types require different handling procedures and staffing


"""

# What is the average ratio of transfer bags vs. checked bags across flights?
# Group by flight and date, count bags by type
bag_summary = (
    bag_df.groupby(['flight_number', 'scheduled_departure_date_local', 'bag_type'])
    .size()
    .unstack(fill_value=0)
)

# Include both Transfer and Hot Transfer in the transfer ratio
bag_summary['transfer_ratio'] = (
    bag_summary.get('Transfer', 0) + bag_summary.get('Hot Transfer', 0)
) / bag_summary.sum(axis=1)

# Display the per-flight ratios
display(bag_summary.head())

# Compute overall ratio across all flights
total_transfer = bag_df[bag_df['bag_type'].isin(['Transfer', 'Hot Transfer'])].shape[0]
total_bags = bag_df.shape[0]
overall_transfer_ratio = total_transfer / total_bags

print(f"\nOverall transfer bag ratio (including hot transfers): {overall_transfer_ratio:.3f}")

pnr_flight_df.columns

type(flight_df['scheduled_arrival_datetime_local'][0])

"""This was to check if in any case the actual time taken by the aircraft was more than the scheduled."""

import pandas as pd

# Ensure datetime columns are actually datetime type
flight_df['actual_departure_datetime_local'] = pd.to_datetime(flight_df['actual_departure_datetime_local'])
flight_df['actual_arrival_datetime_local'] = pd.to_datetime(flight_df['actual_arrival_datetime_local'])

# Compute actual time used on ground in minutes
flight_df['actual_used_minutes'] = (
    (flight_df['actual_departure_datetime_local'] - flight_df['actual_arrival_datetime_local'])
    .dt.total_seconds() / 60
)

# Compare actual used ground time vs scheduled ground time
flight_df['ground_time_exceeded'] = flight_df['actual_used_minutes'] > flight_df['scheduled_ground_time_minutes']

# Inspect
flight_df[['flight_number', 'scheduled_departure_date_local', 'actual_used_minutes', 'actual_ground_time_minutes', 'ground_time_exceeded']].head()

flight_df['ground_time_exceeded'].value_counts()

"""# Question 4: Passenger Load Analysis

## Business Context  
**Competition Question**: *"How do passenger loads compare across flights, and do higher loads correlate with operational difficulty?"*

Passenger load factor affects operational complexity through multiple mechanisms:
- **Boarding Time**: More passengers = longer boarding process
- **Service Requirements**: Higher loads increase service demands
- **Gate Operations**: More passengers require more gate resources
- **Baggage Volume**: Higher loads typically correlate with more baggage

## Hypothesis Testing
We test whether higher passenger loads correlate with operational difficulty by:
1. **Computing Load Factors**: Passengers/Available Seats for each flight
2. **Defining Difficulty Metrics**: Using ground time pressure as operational difficulty proxy
3. **Correlation Analysis**: Statistical relationship between load and difficulty
4. **Practical Significance**: Whether correlations are operationally meaningful


"""

# How do passenger loads compare across flights, and do higher loads correlate with operational difficulty?
# First, get total passengers per flight from PNR
total_pax_per_flight = (
    pnr_flight_df.groupby(['flight_number', 'scheduled_departure_date_local'])['total_pax']
    .sum()
    .reset_index()
)

# Merge with flight_df to get total seats
flight_load_df = flight_df.merge(
    total_pax_per_flight,
    on=['flight_number', 'scheduled_departure_date_local'],
    how='left'
)

# Compute load factor
flight_load_df['load_factor'] = flight_load_df['total_pax'] / flight_load_df['total_seats']

# Optional: compute operational difficulty as flights with scheduled ground time close to minimum turn
flight_load_df['difficulty_flag'] = flight_load_df['scheduled_ground_time_minutes'] <= flight_load_df['minimum_turn_minutes']

# Inspect
flight_load_df[['flight_number', 'scheduled_departure_date_local', 'total_pax', 'total_seats', 'load_factor', 'difficulty_flag']].head()

# Correlation between load factor and difficulty (0/1)
corr = flight_load_df['load_factor'].corr(flight_load_df['difficulty_flag'].astype(int))
print("Correlation between passenger load and operational difficulty:", corr)

"""There is essentially no relationship between passenger load and operational difficulty in your dataset.
Flights with more passengers are not noticeably more difficult to operate than flights with fewer passengers.

# Question 5: Special Service Requests Impact Analysis

## Business Context
**Competition Question**: *"Are high special service requests flights also high-delay after controlling for load?"*

Special Service Requests (SSRs) represent additional operational complexity:
- **Wheelchair Assistance**: Requires specialized equipment and trained personnel
- **Special Meals**: Additional catering coordination
- **Unaccompanied Minors**: Extra documentation and supervision
- **Medical Equipment**: Special handling and power requirements

## Statistical Approach
We use regression analysis to isolate the effect of SSRs on delays while controlling for passenger load:

**Model**: `Arrival Delay = β₀ + β₁(SSR Count) + β₂(Load Factor) + ε`

This approach allows us to:
- **Isolate SSR Impact**: Control for confounding effect of passenger volume
- **Quantify Effect Size**: Understand how much each SSR adds to delay
- **Statistical Significance**: Determine if effects are statistically meaningful
- **Practical Significance**: Assess whether effects matter operationally
"""

# Are high special service requests flights also high-delay after controlling for load?
# Merge SSRs with PNR flight info to get departure date
pnr_remark_with_date = pnr_remark_df.merge(
    pnr_flight_df[['record_locator', 'scheduled_departure_date_local', 'flight_number']],
    on='record_locator',
    how='left'
)

# Count SSRs per flight
ssr_count = (
    pnr_remark_with_date.groupby(['flight_number', 'scheduled_departure_date_local'])
    .size()
    .reset_index(name='ssr_count')
)

# Merge with flight_df
flight_analysis = flight_df.merge(
    total_pax_per_flight,
    on=['flight_number', 'scheduled_departure_date_local'],
    how='left'
).merge(
    ssr_count,
    on=['flight_number', 'scheduled_departure_date_local'],
    how='left'
)

# Fill NaN SSRs with 0 (flights with no SSRs)
flight_analysis['ssr_count'] = flight_analysis['ssr_count'].fillna(0)

# Compute arrival delay in minutes
flight_analysis['scheduled_arrival_datetime_local'] = pd.to_datetime(flight_analysis['scheduled_arrival_datetime_local'])
flight_analysis['actual_arrival_datetime_local'] = pd.to_datetime(flight_analysis['actual_arrival_datetime_local'])

flight_analysis['arrival_delay'] = (
    (flight_analysis['actual_arrival_datetime_local'] - flight_analysis['scheduled_arrival_datetime_local'])
    .dt.total_seconds() / 60
)

# Compute passenger load ---
flight_analysis['load_factor'] = flight_analysis['total_pax'] / flight_analysis['total_seats']

# Regression: delay ~ SSR count + load factor
import statsmodels.api as sm
X = flight_analysis[['ssr_count', 'load_factor']]
X = sm.add_constant(X)  # adds intercept
y = flight_analysis['arrival_delay']

model = sm.OLS(y, X).fit()

# Results
print(model.summary())

"""# Statistical Model Results: SSR and Load Factor Impact on Flight Delays

## Model Performance Summary

### Overall Model Fit
- **R-squared: 0.029 (2.9%)**
  - The model explains only 2.9% of variance in arrival delays
  - **Interpretation**: While our variables are statistically significant, the majority (97.1%) of delay variation is driven by other operational factors
  - **Business Context**: This low explanatory power is actually typical in airline operations due to the complex, multi-factor nature of delays

## Key Statistical Findings

### 1. Special Service Requests Impact
- **Coefficient: +1.75 minutes per SSR**
- **Statistical Significance: p < 0.001 (highly significant)**
- **Business Translation**: Each additional special service request adds approximately **1.75 minutes of delay** to flight operations
- **Operational Impact**: For flights with multiple SSRs (wheelchairs, special meals, medical equipment), delays accumulate predictably

### 2. Load Factor Impact (Surprising Finding)
- **Coefficient: -51.47 minutes**
- **Statistical Significance: p < 0.001 (highly significant)**
- **Counterintuitive Result**: Higher passenger loads are associated with **reduced delays**
- **Possible Explanations**:
  - **Operational Priority**: Higher-load flights may receive priority handling due to revenue impact
  - **Resource Allocation**: Airlines may assign better crews/gates to high-revenue, high-load flights
  - **Operational Efficiency**: Full flights may follow more standardized, efficient procedures
  - **Schedule Optimization**: High-load routes may have more optimized scheduling

### 3. Baseline Operations
- **Intercept: 61.87 minutes**
- **Interpretation**: Expected delay for flights with zero SSRs and zero passengers
- **Note**: This represents the baseline operational delay independent of passenger-related factors

## Business Implications

### What This Means for United Airlines:

#### Confirmed Insights
1. **SSR Planning**: Each special service request reliably adds ~2 minutes to operations
   - **Actionable**: Budget additional ground time for high-SSR flights
   - **Resource Allocation**: Deploy specialized equipment proactively for SSR-heavy flights

#### Unexpected Insights  
2. **Load Factor Paradox**: Higher passenger loads correlate with better on-time performance
   - **Strategic Implication**: Revenue optimization (higher loads) may align with operational efficiency
   - **Investigation Needed**: Further analysis required to understand this relationship

#### Model Limitations
3. **Limited Explanatory Power**: 97.1% of delay variation comes from other factors
   - **Missing Variables**: Weather, ATC delays, mechanical issues, crew scheduling, airport congestion
   - **Next Steps**: Incorporate additional operational variables in future models

## Operational Recommendations

### Immediate Actions
1. **SSR Resource Planning**
   - Add 2-minute buffer per SSR to ground time calculations
   - Pre-position specialized equipment for high-SSR flights
   - Train ground crews on efficient SSR handling procedures

2. **Load Factor Strategy**
   - Investigate why high-load flights perform better operationally
   - Consider applying successful high-load practices to lower-load flights
   - Maintain focus on revenue optimization without compromising this efficiency advantage

**Bottom Line**: While SSRs and load factors have measurable impacts on delays, they represent just the tip of the iceberg in airline operational complexity. This analysis provides a solid foundation for understanding passenger-related delay drivers while highlighting the need for more comprehensive operational modeling in future phases.

# Key Findings Summary

## Critical Insights for United Airlines Operations

### 1. Delay Patterns
- **Average Delay**: 47.05 minutes (late departures)
21.18 minutes (early + late both)
- **Late Departure Rate**: 49.61 % of flights

### 2. Ground Time Pressure
- **At-Risk Flights**: 8.05% operate at/below minimum turn time  
- **Operational Risk**: These flights require priority attention and resource allocation

### 3. Baggage Complexity
- **Transfer Ratio**: 0.57 of bags are transfers or 57% of total bags
- **Operational Planning**: Transfer-heavy flights need specialized handling resources

### 4. Load Factor Correlation
- **Statistical Relationship**:  -0.007 correlation with operational difficulty
- **Practical Significance**: There is essentially no relationship between passenger load and operational difficulty in your dataset. Flights with more passengers are not noticeably more difficult to operate than flights with fewer passengers.

### 5. Special Service Impact
- **Per-SSR Delay Impact**: Each additional SSR adds ~1.75 minutes of delay
- **Load Factor Effect**:~ -51 mins
- **Combined Effects**:So while SSRs and load factor are statistically significant, there are many other factors affecting delays (weather, airport congestion, crew availability, aircraft type, etc.).

## Next Steps
These EDA findings provide the foundation for developing our Flight Difficulty Scoring algorithm in Deliverable 2, where we'll use these operational complexity drivers to create a predictive scoring system.
"""

